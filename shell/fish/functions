function vs
    if test $argv
        code -a --goto $argv
    else
        code -a .
    end
end

function e
    if test $argv
        $EDITOR $argv
    else
        $EDITOR .
    end
end

function g
    if test $argv
        git $argv
    else
        git status --short
        git diff --shortstat | grep -v "EMPTY"
    end
end

function gl
    if test $argv
        git --no-pager log --oneline -$argv
    else
        git --no-pager log --oneline -1
    end
end

function sw
    if test $argv
        git switch $argv
    else
        git switch -
    end
end

function install_pg
    gem install pg  -v '1.2.3' -- --with-pg-config=(asdf where postgres)"/bin/pg_config"
end

function gbf
  set branch (git branch -vv | fzf --preview 'git diff master..{2}')
  git checkout (echo $branch | awk '{print $1}')
end

function gbc
    set branch (string join _ $argv)
    git switch -c $branch
end

function o
    if test $argv
        open $argv
    else
        open .
    end
end

function gcf
    git log $argv --oneline -1
    git commit --fixup="$argv"; and env GIT_SEQUENCE_EDITOR=true git rebase --autosquash --autostash "$argv"^ -i
end


function evs
        env | fzf --height 10%
end

function ff
    if test $argv
        set fzf_file (fd . $argv[1] | fzf --height 20% --preview "bat --style numbers,changes --color=always {}")
    else
        set fzf_file (fd . . | fzf --height 20% --preview "bat --style numbers,changes --color=always {}")
    end
    if test $status -eq 0
        if test -d $fzf_file
            cd $fzf_file
        else
            $EDITOR $fzf_file
        end
    end
end

function git_track_untracked
    git ls-files -z --others --exclude-standard | xargs -0 git add -N
end

function git_untrack_new_blank
    git diff -z --name-only --no-renames --diff-filter=A | xargs -0 git reset --quiet --
end

function yt
    echo 'Switching to Download/videos'
    mkdir -p $HOME/Downloads/videos
    cd $HOME/Downloads/videos
    echo 'Downloading video using yt-dlp'
    yt-dlp --restrict-filenames -o "%(webpage_url)s - %(title).180s.%(ext)s" "$argv"
end

function music
    echo 'Switching to Downloads/Music'
    mkdir -p $HOME/Downloads/Music
    cd $HOME/Downloads/Music
    echo 'Downloading song using yt-dlp'
    yt-dlp -f bestaudio[ext=m4a] --restrict-filenames -o "%(title).180s.%(ext)s" "$argv"
end
    
function logic
     echo -e "\033[1;31m If applied this commit will... \033[0m"
end

function stop
    if test -d $argv
        echo "No port provided, killing port 3000 "
        kill -9 (lsof -i tcp:3000 -t)
    else
        kill -9 (lsof -i tcp:$argv -t)
    end
end

function alert
    eval "$argv"
    echo "$argv" | xargs -I {} osascript -e 'display alert "{} complete"'
end

function tmux_title
  clear
  tmux set-option -g pane-border-style "bg=blue,fg=white"
  printf "\033]2;%s\033\\" "$argv"
end

function up
  if test -d $argv
    cd ..
  else if string match -qr '^[0-9]+$' $argv[1]
    for i in (seq 1 $argv[1])
        cd ..
    end
  else
    echo "Usage: Provide a number of directories to go up. Defaults to 1"
  end
end

function mise_cleanse
    set -l lang $argv[1]
    if test -z "$lang"
        set lang ruby
    end

    set -l latest_version (mise latest $lang)

    for lang_version in (mise list $lang | grep -v "$latest_version" | awk '{print $2}')
        mise uninstall $lang $lang_version
    end
end

function freq
    cat $XDG_DATA_HOME/fish/history/* |\
    cut -d';' -f2 |\
    sed -E "s/ *[0-9]+  //" |\
    sort |\
    uniq -c |\
    sort -rn |\
    head -50
end

function smart_cd
    set base_dir "$argv[1]"  # Change this to the actual path of your 'con' directory
    cd $base_dir
    set partial $argv[2]

    if test -n "$partial"
        set matches (find $base_dir -maxdepth 1 -type d -name "$partial*")
        if test (count $matches) -gt 0
            cd $matches[1]
            echo "Changed to directory: $matches[1]"
        else
            echo "No matching directory found for '$partial'"
        end
    else
    end
end

function ef
    if test (count $argv) -gt 0
        set fzf_file (fd . $argv[1] | fzf --height 20%)
    else
        set fzf_file (fd | fzf --height 20%)
    end
    if test $status -eq 0
        eval $EDITOR "$fzf_file"
    end
end

function ds_store_remove
    find . -name ".DS_Store" -type f -print
    find . -name ".DS_Store" -type f -print0 | xargs -0 rm
end

function dotter_update
  cd $HOME/.dotfiles
  dotter \
    --global-config $HOME/.dotfiles/config/dotter/global.toml \
    --local-config $HOME/.dotfiles/config/dotter/local.toml \
    --cache-file $XDG_CACHE_HOME/dotter.toml \
    --cache-directory $XDG_CACHE_HOME/dotter/ \
    --post-deploy $HOME/.dotfiles/config/dotter/post_deploy.sh \
    --verbose --verbose
end

function path
    set -l green (set_color green)
    set -l blue (set_color blue)
    set -l red (set_color red)
    set -l cyan (set_color cyan)
    set -l magenta (set_color magenta)
    set -l yellow (set_color yellow)
    set -l reset (set_color normal)

    set -l index 1
    for path_item in (string split : $PATH)
        set -l colored_path $path_item
        set colored_path (string replace -a '.local/share/mise/installs/' "$red.local/share/mise/installs/$reset" $colored_path)
        set colored_path (string replace -a '/usr' "$green/usr$reset" $colored_path)
        set colored_path (string replace -a '/bin' "$blue/bin$reset" $colored_path)
        set colored_path (string replace -a '/opt' "$cyan/opt$reset" $colored_path)
        set colored_path (string replace -a '/sbin' "$magenta/sbin$reset" $colored_path)
        set colored_path (string replace -a "$HOME" "\$HOME$reset" $colored_path)
        set colored_path (string replace -a '/local' "$yellow/local$reset" $colored_path)

        echo "$index: $colored_path"
        set index (math $index + 1)
    end
end

function d
    dirh
end

function doctor_update
    printf "\033[1;31mBrew Doctor issues \033[0m\n"
    brew doctor
end

function fresh_update
    printf "\033[1;31mUpdating Fresh \033[0m\n"
    fresh up | rg -v "Current branch master is up to date."
end

function mise_update
    printf "\033[1;31mUpdating Mise plugins\033[0m\n"
    for lang in (ls "$HOME/.dotfiles/language")
        mise install "$lang@latest"
        mise use -g "$lang@latest"
    end
    mise prune --yes
end

function zinit_update
    printf "\033[1;31mUpdating Zsh plugins \033[0m\n"
    zi update --parallel
end

function fisher_update
    printf "\033[1;31mUpdating Fisher Plugins \033[0m\n"
    echo 'fisher update' | fish | rg -v "has unsynchronized changes|$XDG_CONFIG_HOME/fish/|Fetching"
    printf "\033[1;31mUpdating Abbreviations Tips \033[0m\n"
    fish "$XDG_CONFIG_HOME/fish/functions/__abbr_tips_init.fish"
end

function ruby_update
    printf "\033[1;31mUpdating Ruby Gems \033[0m\n"
    cd $XDG_CONFIG_HOME/ruby && gem update --system
    printf "\033[1;31mGenerating Gemfile \033[0m\n"
    cd $XDG_CONFIG_HOME/ruby && rm Gemfile
    cd $XDG_CONFIG_HOME/ruby &&
        echo "# frozen_string_literal: true\n" >>Gemfile &&
        echo "source 'https://rubygems.org'\n" >>Gemfile &&
        sed "s/^/gem '/" ~/.dotfiles/language/ruby/default-gems |
        sed 's/$/'\''/g' >>Gemfile
    printf "\033[1;31mUpdating Bundler \033[0m\n"
    cd $XDG_CONFIG_HOME/ruby && gem install bundler
    printf "\033[1;31mUpdating Gems \033[0m\n"
    cd $XDG_CONFIG_HOME/ruby && bundle update
end

function brew_update
    printf "\033[1;31mUpdating Brewfile \033[0m\n"
    cd ~/.dotfiles/brew && brew bundle dump --force --describe
    printf "\033[1;31mUpdating Brew \033[0m\n"
    brew update
    printf "\033[1;31mUpgrading Brew \033[0m\n"
    set OUTDATED (brew outdated) && brew upgrade
    printf "\033[1;31mOutdated Casks \033[0m\n"
    brew upgrade --cask --greedy
    echo $OUTDATED
end

function mac_software_update
    printf "\033[1;31mUpdating Mac Software \033[0m\n"
    xcode-select -p 1>/dev/null
    set xcode_installed $status
    if test $xcode_installed -ne 0
        printf 'XCode CLI Tools not installed, Installing now'
        xcode-select --install
    end
    softwareupdate -ia
end
